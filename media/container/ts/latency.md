# MPEG-TS 流延迟分析

## 概要

TS数据可以直接保存文件也可以直接用于网络流传输。在传输时通常发送端会将音视频帧编码后的码流包组成PES包然后再拆分组成TS包，接收端收到TS包后再提取并重组PES包，然后再提取码流包，组包和拆包过程可能引入的延迟。这里主要通过ffmpeg的流程来分析这些延迟。

## 测试环境

单机环境，一个发送demo，一个接收demo，通过srt传输HEVC单视频流。延迟测定的参考时间使用本机时间映射到PTS实现。

## muxer

发送媒体数据时先调用`av_interleaved_write_frame`接口传入码流时，会直接调用到`mpegts_write_packet`接口再触发`mpegts_write_pes`将帧数据按照pes数据格式组织到TS包，然后通过`avio_write`送IO。这里实测延迟低于1毫秒。

IO部分发送主要看带宽控制，以SRT为例，IO部分一般将数据放入发送队列按照设定的带宽发送包，这部分延迟主要受限于网络参数。

__综上，muxer阶段的延迟都是低于1毫秒的。__

## demuxer

demuxer阶段通过本地网络测试（延迟低于1毫秒）发现在`av_read_frame`处收到数据的延迟打印总是约等于两倍于帧率的倒数，按理说传输延迟很大，整体的应该在一帧的延迟内。

demuxer的流程主要就是将TS包恢复到PES包给应用就行，ffmpeg里面主要在`handle_packets`接口处理TS包恢复过程，这里加一个延迟统计，输出的延迟总是约等于帧率的倒数，按理说传输时间肯定在一帧内的，为什么每次都是大于一帧？

通过跟踪代码发现，这个里面是在收到TS起始包（pes起始包，或者PMT PAT包）后才会将上一帧数据返回，为什么要等起始包呢？

分析下[PES数据格式](https://www.cnblogs.com/jiayayao/p/6832614.html)，PES头数据主要由3字节起始码，单字节流ID，双字节PES包长度，PES包数据组成。恢复PES包时根据包长度字段就可以判断PES接收完成，但是它最大值只有65535，视频包的数据长度很可能大于该值，这时就只能将这个值设置为0，通过下一个起始包来判断结束了。TS包头中只设计了起始标志，没有像RTP那样设置结束标志，所以从TS格式层面没法解决这个问题，这样就导致了TS恢复的延迟取决于后续的数据发送延迟。

`av_read_frame`处还有一个帧率倒数的延迟，这是为什么？通过对`read_frame_internal`代码分析，发现是会在`AVCodecParser`的`hevc_parse`还有一帧延迟，它里面主要是会解析帧类型，根据输入的码流数据按帧分隔出来（根据AUD和帧头中带的数据类型），所以这里也是要等到输入下一帧时才能输出上一帧数据。上面TS数据恢复PES包时已经是按帧恢复了，这里是不是可以去掉呢？理论上是可行的，但是PES的长度未知，目前在解析时通过预先申请一块指定大小的内存存放，当数据满后直接回送到parse流程，所以这里还不能省略。

__综上，demuxer阶段存在固定的两帧的延迟。__
